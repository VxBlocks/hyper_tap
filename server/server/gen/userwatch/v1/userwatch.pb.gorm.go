package userwatchv1

import (
	context "context"
	fmt "fmt"
	gateway "github.com/infobloxopen/atlas-app-toolkit/v2/gateway"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type UserWatchORM struct {
	CreatedAt   *time.Time
	Events      pq.StringArray `gorm:"type:text[]"`
	Id          int64          `gorm:"primaryKey"`
	LowerPrice  float32
	UpdatedAt   *time.Time
	UserId      string `gorm:"index:user_id_idx"`
	WatchUserId string
}

// TableName overrides the default tablename generated by GORM
func (UserWatchORM) TableName() string {
	return "user_watches"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserWatch) ToORM(ctx context.Context) (UserWatchORM, error) {
	to := UserWatchORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWatchWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.UserId = m.UserId
	to.WatchUserId = m.WatchUserId
	to.LowerPrice = m.LowerPrice
	if m.Events != nil {
		to.Events = make(pq.StringArray, len(m.Events))
		copy(to.Events, m.Events)
	}
	if posthook, ok := interface{}(m).(UserWatchWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserWatchORM) ToPB(ctx context.Context) (UserWatch, error) {
	to := UserWatch{}
	var err error
	if prehook, ok := interface{}(m).(UserWatchWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.UserId = m.UserId
	to.WatchUserId = m.WatchUserId
	to.LowerPrice = m.LowerPrice
	if m.Events != nil {
		to.Events = make(pq.StringArray, len(m.Events))
		copy(to.Events, m.Events)
	}
	if posthook, ok := interface{}(m).(UserWatchWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserWatch the arg will be the target, the caller the one being converted from

// UserWatchBeforeToORM called before default ToORM code
type UserWatchWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserWatchORM) error
}

// UserWatchAfterToORM called after default ToORM code
type UserWatchWithAfterToORM interface {
	AfterToORM(context.Context, *UserWatchORM) error
}

// UserWatchBeforeToPB called before default ToPB code
type UserWatchWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserWatch) error
}

// UserWatchAfterToPB called after default ToPB code
type UserWatchWithAfterToPB interface {
	AfterToPB(context.Context, *UserWatch) error
}

type UserWatchMsgORM struct {
	CreatedAt   *time.Time
	Event       string
	Id          int64 `gorm:"primaryKey"`
	Msg         string
	Size        string
	Time        int64
	Token       string
	UserId      string `gorm:"index:user_id_idx"`
	WatchUserId string
}

// TableName overrides the default tablename generated by GORM
func (UserWatchMsgORM) TableName() string {
	return "user_watch_msgs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *UserWatchMsg) ToORM(ctx context.Context) (UserWatchMsgORM, error) {
	to := UserWatchMsgORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWatchMsgWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	to.UserId = m.UserId
	to.WatchUserId = m.WatchUserId
	to.Event = m.Event
	to.Msg = m.Msg
	to.Token = m.Token
	to.Size = m.Size
	to.Time = m.Time
	if posthook, ok := interface{}(m).(UserWatchMsgWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserWatchMsgORM) ToPB(ctx context.Context) (UserWatchMsg, error) {
	to := UserWatchMsg{}
	var err error
	if prehook, ok := interface{}(m).(UserWatchMsgWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	to.UserId = m.UserId
	to.WatchUserId = m.WatchUserId
	to.Event = m.Event
	to.Msg = m.Msg
	to.Token = m.Token
	to.Size = m.Size
	to.Time = m.Time
	if posthook, ok := interface{}(m).(UserWatchMsgWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type UserWatchMsg the arg will be the target, the caller the one being converted from

// UserWatchMsgBeforeToORM called before default ToORM code
type UserWatchMsgWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserWatchMsgORM) error
}

// UserWatchMsgAfterToORM called after default ToORM code
type UserWatchMsgWithAfterToORM interface {
	AfterToORM(context.Context, *UserWatchMsgORM) error
}

// UserWatchMsgBeforeToPB called before default ToPB code
type UserWatchMsgWithBeforeToPB interface {
	BeforeToPB(context.Context, *UserWatchMsg) error
}

// UserWatchMsgAfterToPB called after default ToPB code
type UserWatchMsgWithAfterToPB interface {
	AfterToPB(context.Context, *UserWatchMsg) error
}

// DefaultCreateUserWatch executes a basic gorm create call
func DefaultCreateUserWatch(ctx context.Context, in *UserWatch, db *gorm.DB) (*UserWatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserWatchORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserWatch(ctx context.Context, in *UserWatch, db *gorm.DB) (*UserWatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserWatchORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserWatchORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserWatchORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserWatch(ctx context.Context, in *UserWatch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserWatchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserWatchORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserWatchSet(ctx context.Context, in []*UserWatch, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserWatchORM{})).(UserWatchORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserWatchORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserWatchORM{})).(UserWatchORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserWatchORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserWatch, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserWatch, *gorm.DB) error
}

// DefaultStrictUpdateUserWatch clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserWatch(ctx context.Context, in *UserWatch, db *gorm.DB) (*UserWatch, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserWatch")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	var count int64
	lockedRow := &UserWatchORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type UserWatchORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserWatch executes a basic gorm update call with patch behavior
func DefaultPatchUserWatch(ctx context.Context, in *UserWatch, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserWatch, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserWatch
	var err error
	if hook, ok := interface{}(&pbObj).(UserWatchWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserWatch(ctx, &UserWatch{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWatchWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserWatch(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWatchWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserWatch(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWatchWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWatchWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserWatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserWatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserWatch, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserWatch, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserWatch executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserWatch(ctx context.Context, objects []*UserWatch, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserWatch, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserWatch, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserWatch(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserWatch patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserWatch(ctx context.Context, patchee *UserWatch, patcher *UserWatch, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserWatch, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"WatchUserId" {
			patchee.WatchUserId = patcher.WatchUserId
			continue
		}
		if f == prefix+"LowerPrice" {
			patchee.LowerPrice = patcher.LowerPrice
			continue
		}
		if f == prefix+"Events" {
			patchee.Events = patcher.Events
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserWatch executes a gorm list call
func DefaultListUserWatch(ctx context.Context, db *gorm.DB) ([]*UserWatch, error) {
	in := UserWatch{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserWatchORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserWatch{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserWatchORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserWatchORM) error
}

// DefaultCreateUserWatchMsg executes a basic gorm create call
func DefaultCreateUserWatchMsg(ctx context.Context, in *UserWatchMsg, db *gorm.DB) (*UserWatchMsg, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserWatchMsgORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUserWatchMsg(ctx context.Context, in *UserWatchMsg, db *gorm.DB) (*UserWatchMsg, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserWatchMsgORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserWatchMsgORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserWatchMsgORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUserWatchMsg(ctx context.Context, in *UserWatchMsg, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserWatchMsgORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserWatchMsgORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserWatchMsgSet(ctx context.Context, in []*UserWatchMsg, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserWatchMsgORM{})).(UserWatchMsgORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserWatchMsgORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserWatchMsgORM{})).(UserWatchMsgORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserWatchMsgORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*UserWatchMsg, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*UserWatchMsg, *gorm.DB) error
}

// DefaultStrictUpdateUserWatchMsg clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUserWatchMsg(ctx context.Context, in *UserWatchMsg, db *gorm.DB) (*UserWatchMsg, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUserWatchMsg")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	var count int64
	lockedRow := &UserWatchMsgORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type UserWatchMsgORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUserWatchMsg executes a basic gorm update call with patch behavior
func DefaultPatchUserWatchMsg(ctx context.Context, in *UserWatchMsg, updateMask *field_mask.FieldMask, db *gorm.DB) (*UserWatchMsg, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj UserWatchMsg
	var err error
	if hook, ok := interface{}(&pbObj).(UserWatchMsgWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUserWatchMsg(ctx, &UserWatchMsg{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWatchMsgWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUserWatchMsg(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWatchMsgWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUserWatchMsg(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWatchMsgWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWatchMsgWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *UserWatchMsg, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *UserWatchMsg, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *UserWatchMsg, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *UserWatchMsg, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUserWatchMsg executes a bulk gorm update call with patch behavior
func DefaultPatchSetUserWatchMsg(ctx context.Context, objects []*UserWatchMsg, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*UserWatchMsg, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*UserWatchMsg, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUserWatchMsg(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUserWatchMsg patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUserWatchMsg(ctx context.Context, patchee *UserWatchMsg, patcher *UserWatchMsg, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*UserWatchMsg, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"WatchUserId" {
			patchee.WatchUserId = patcher.WatchUserId
			continue
		}
		if f == prefix+"Event" {
			patchee.Event = patcher.Event
			continue
		}
		if f == prefix+"Msg" {
			patchee.Msg = patcher.Msg
			continue
		}
		if f == prefix+"Token" {
			patchee.Token = patcher.Token
			continue
		}
		if f == prefix+"Size" {
			patchee.Size = patcher.Size
			continue
		}
		if f == prefix+"Time" {
			patchee.Time = patcher.Time
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUserWatchMsg executes a gorm list call
func DefaultListUserWatchMsg(ctx context.Context, db *gorm.DB) ([]*UserWatchMsg, error) {
	in := UserWatchMsg{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserWatchMsgORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserWatchMsgORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*UserWatchMsg{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserWatchMsgORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserWatchMsgORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserWatchMsgORM) error
}
